using System;
using System.Collections.Generic;
using System.ComponentModel.Design;
using System.IO;
using ColossalFramework;
using ColossalFramework.Math;
using ColossalFramework.UI;
using UnityEngine;

namespace TrafficManager
{
    public class TrafficLightTool : DefaultTool
    {
        public enum ToolMode
        {
            None,
            SwitchTrafficLight,
            AddPrioritySigns,
            ManualSwitch,
            TimedLightsSelectNode,
            TimedLightsShowLights,
            LaneChange
        }

        private ToolMode _toolMode;

        private bool _mouseDown = false;
        private bool _mouseClicked = false;

        private ushort _hoveredNetNodeIdx;
        private static ushort _selectedNetNodeIdx;

        private int _hoveredSegmentIdx;
        private static int _selectedSegmentIdx;

        public static List<ushort> SelectedNodeIndexes = new List<ushort>();

        private int[] _hoveredButton = new int[2];
        private ushort _hoveredNode;

        // simple
        private Texture2D light_simple_1 = new Texture2D(103, 243);
        private Texture2D light_simple_2 = new Texture2D(103, 243);
        private Texture2D light_simple_3 = new Texture2D(103, 243);
        // forward
        private Texture2D light_forward_1 = new Texture2D(103, 243);
        private Texture2D light_forward_2 = new Texture2D(103, 243);
        private Texture2D light_forward_3 = new Texture2D(103, 243);
        // right
        private Texture2D light_right_1 = new Texture2D(103, 243);
        private Texture2D light_right_2 = new Texture2D(103, 243);
        private Texture2D light_right_3 = new Texture2D(103, 243);
        // left
        private Texture2D light_left_1 = new Texture2D(103, 243);
        private Texture2D light_left_2 = new Texture2D(103, 243);
        private Texture2D light_left_3 = new Texture2D(103, 243);
        // forwardright
        private Texture2D light_forwardright_1 = new Texture2D(103, 243);
        private Texture2D light_forwardright_2 = new Texture2D(103, 243);
        private Texture2D light_forwardright_3 = new Texture2D(103, 243);
        // forwardleft
        private Texture2D light_forwardleft_1 = new Texture2D(103, 243);
        private Texture2D light_forwardleft_2 = new Texture2D(103, 243);
        private Texture2D light_forwardleft_3 = new Texture2D(103, 243);
        // yellow
        private Texture2D light_yellow = new Texture2D(103, 243);
        // pedestrian
        private Texture2D pedestrian_light_1 = new Texture2D(73, 123);
        private Texture2D pedestrian_light_2 = new Texture2D(73, 123);
        // light mode
        private Texture2D light_mode = new Texture2D(103, 95);
        private Texture2D light_counter = new Texture2D(103, 95);
        // pedestrian mode
        private Texture2D pedestrian_mode_1 = new Texture2D(73, 70);
        private Texture2D pedestrian_mode_2 = new Texture2D(73, 73);

        // priority signs
        private Texture2D signStop = new Texture2D(200, 200);
        private Texture2D signYield = new Texture2D(200, 200);
        private Texture2D signPriority = new Texture2D(200, 200);
        private Texture2D signNone = new Texture2D(200, 200);

        private GUIStyle counterStyle = new GUIStyle();

        private bool uiClickedSegment = false;
        private Rect _windowRect = new Rect(11, 410, 250, 150);
        private Rect _windowRect2 = new Rect(11, 410, 250, 150);

        public float stepValue = 1f;

        protected override void Awake()
        {
            // simple
            light_simple_1.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_1_1.png")));
            light_simple_2.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_1_2.png")));
            light_simple_3.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_1_3.png")));
            // forward
            light_forward_1.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_2_1.png")));
            light_forward_2.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_2_2.png")));
            light_forward_3.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_2_3.png")));
            // right
            light_right_1.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_3_1.png")));
            light_right_2.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_3_2.png")));
            light_right_3.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_3_3.png")));
            // left
            light_left_1.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_4_1.png")));
            light_left_2.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_4_2.png")));
            light_left_3.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_4_3.png")));
            // forwardright
            light_forwardright_1.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_5_1.png")));
            light_forwardright_2.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_5_2.png")));
            light_forwardright_3.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_5_3.png")));
            // forwardleft
            light_forwardleft_1.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_6_1.png")));
            light_forwardleft_2.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_6_2.png")));
            light_forwardleft_3.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_6_3.png")));
            // yellow
            light_yellow.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_yellow.png")));
            // pedestrian
            pedestrian_light_1.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "pedestrian_light_1.png")));
            pedestrian_light_2.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "pedestrian_light_2.png")));
            // light mode
            light_mode.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_mode.png")));
            light_counter.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "light_counter.png")));
            // pedestrian mode
            pedestrian_mode_1.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "pedestrian_mode_1.png")));
            pedestrian_mode_2.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "pedestrian_mode_2.png")));

            // priority signs
            signStop.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "sign_stop.png")));
            signYield.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "sign_yield.png")));
            signPriority.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "sign_priority.png")));
            signNone.LoadImage(File.ReadAllBytes(Path.Combine(Application.dataPath, "sign_none.png")));

            base.Awake();
        }

        // Expose protected property
        public new CursorInfo ToolCursor
        {
            get { return base.ToolCursor; }
            set { base.ToolCursor = value; }
        }

        public static ushort SelectedNode
        {
            get { return _selectedNetNodeIdx; }
            set { }
        }

        public static int SelectedSegment
        {
            get { return _selectedSegmentIdx; }
            set { }
        }

        public void setToolMode(ToolMode mode)
        {
            _toolMode = mode;

            if (mode != ToolMode.ManualSwitch)
            {
                DisableManual();
            }

            _selectedNetNodeIdx = 0;
            _selectedSegmentIdx = 0;

            if (mode != ToolMode.TimedLightsSelectNode && mode != ToolMode.TimedLightsShowLights)
            {
                SelectedNodeIndexes.Clear();
            }
        }

        // Overridden to disable base class behavior
        protected override void OnEnable()
        {
        }

        // Overridden to disable base class behavior
        protected override void OnDisable()
        {
        }

        public override void RenderGeometry(RenderManager.CameraInfo cameraInfo)
        {
            if (_hoveredNetNodeIdx != 0)
            {
                m_toolController.RenderCollidingNotifications(cameraInfo, 0, 0);
            }
        }

        public override void RenderOverlay(RenderManager.CameraInfo cameraInfo)
        {
            if (_toolMode == ToolMode.SwitchTrafficLight)
            {
                if (m_toolController.IsInsideUI || !Cursor.visible)
                {
                    return;
                }

                _renderOverlaySwitch(cameraInfo);
            }
            else if (_toolMode == ToolMode.AddPrioritySigns)
            {
                _renderOverlayPriority(cameraInfo);
            }
            else if (_toolMode == ToolMode.ManualSwitch)
            {
                _renderOverlayManual(cameraInfo);
            }
            else if (_toolMode == ToolMode.TimedLightsSelectNode)
            {
                _renderOverlayTimedSelectNodes(cameraInfo);
            }
            else if (_toolMode == ToolMode.TimedLightsShowLights)
            {
                
            }
            else if (_toolMode == ToolMode.LaneChange)
            {
                _renderOverlayLaneChange(cameraInfo);
            }
            else
            {
                base.RenderOverlay(cameraInfo);
            }
        }

        public void _renderOverlaySwitch(RenderManager.CameraInfo cameraInfo)
        {
            if (_hoveredNetNodeIdx != 0)
            {
                Bezier3 bezier;

                var node = GetNetNode(_hoveredNetNodeIdx);
                var segment = Singleton<NetManager>.instance.m_segments.m_buffer[(int) node.m_segment0];

                bezier.a = node.m_position;
                bezier.d = node.m_position;

                var color = GetToolColor(_mouseDown, false);

                NetSegment.CalculateMiddlePoints(bezier.a, segment.m_startDirection, bezier.d, segment.m_endDirection,
                    false, false, out bezier.b, out bezier.c);
                _renderOverlayDraw(cameraInfo, bezier, color);
            }
        }

        public void _renderOverlayPriority(RenderManager.CameraInfo cameraInfo)
        {
            if (_hoveredNetNodeIdx != 0 && _hoveredNetNodeIdx != _selectedNetNodeIdx)
            {
                Bezier3 bezier;

                var node = GetNetNode(_hoveredNetNodeIdx);
                var segment = Singleton<NetManager>.instance.m_segments.m_buffer[(int) node.m_segment0];

                if ((node.m_flags & NetNode.Flags.TrafficLights) == NetNode.Flags.None)
                {
                    bezier.a = node.m_position;
                    bezier.d = node.m_position;

                    var color = GetToolColor(false, false);

                    NetSegment.CalculateMiddlePoints(bezier.a, segment.m_startDirection, bezier.d,
                        segment.m_endDirection, false, false, out bezier.b, out bezier.c);
                    _renderOverlayDraw(cameraInfo, bezier, color);
                }
            }
        }

        public void _renderOverlayManual(RenderManager.CameraInfo cameraInfo)
        {
            if (_selectedNetNodeIdx != 0)
            {
                var node = GetNetNode(_selectedNetNodeIdx);

                var colorGray = new Color(0.25f, 0.25f, 0.25f, 0.25f);

                var segmentId = 0;

                var color2 = colorGray;

                var nodeSimulation = CustomRoadAI.GetNodeSimulation(_selectedNetNodeIdx);

                for (var i = 0; i < 8; i++)
                {
                    segmentId = node.GetSegment(i);

                    if (segmentId != 0)
                    {
                        var segment = Singleton<NetManager>.instance.m_segments.m_buffer[(int) segmentId];

                        var position = node.m_position;

                        if (segment.m_startNode == _selectedNetNodeIdx)
                        {
                            position.x += segment.m_startDirection.x*10f;
                            position.y += segment.m_startDirection.y*10f;
                            position.z += segment.m_startDirection.z*10f;
                        }
                        else
                        {
                            position.x += segment.m_endDirection.x*10f;
                            position.y += segment.m_endDirection.y*10f;
                            position.z += segment.m_endDirection.z*10f;
                        }

                        if (nodeSimulation == null || !TrafficLightsManual.IsSegmentLight(_selectedNetNodeIdx, segmentId))
                        {
                            float width = _hoveredButton[0] == segmentId ? 11.25f : 10f;

                            _renderOverlayDraw(cameraInfo, color2, position, width, segmentId != _hoveredButton[0]);
                        }
                    }
                }
            }
            else
            {
                if (_hoveredNetNodeIdx != 0)
                {
                    Bezier3 bezier;

                    var node = GetNetNode(_hoveredNetNodeIdx);
                    var segment = Singleton<NetManager>.instance.m_segments.m_buffer[(int) node.m_segment0];

                    if ((node.m_flags & NetNode.Flags.TrafficLights) != NetNode.Flags.None)
                    {
                        bezier.a = node.m_position;
                        bezier.d = node.m_position;

                        var color = GetToolColor(false, false);

                        NetSegment.CalculateMiddlePoints(bezier.a, segment.m_startDirection, bezier.d,
                            segment.m_endDirection, false, false, out bezier.b, out bezier.c);
                        _renderOverlayDraw(cameraInfo, bezier, color);
                    }
                }
            }
        }

        public void _renderOverlayTimedSelectNodes(RenderManager.CameraInfo cameraInfo)
        {
            if (_hoveredNetNodeIdx != 0 && !containsListNode(_hoveredNetNodeIdx) && !m_toolController.IsInsideUI && Cursor.visible)
            {
                Bezier3 bezier;

                var node = GetNetNode(_hoveredNetNodeIdx);
                var segment = Singleton<NetManager>.instance.m_segments.m_buffer[(int)node.m_segment0];

                if ((node.m_flags & NetNode.Flags.TrafficLights) != NetNode.Flags.None)
                {
                    bezier.a = node.m_position;
                    bezier.d = node.m_position;

                    var color = GetToolColor(false, false);

                    NetSegment.CalculateMiddlePoints(bezier.a, segment.m_startDirection, bezier.d,
                        segment.m_endDirection, false, false, out bezier.b, out bezier.c);
                    _renderOverlayDraw(cameraInfo, bezier, color);
                }
            }

            if (SelectedNodeIndexes.Count > 0)
            {
                for (var i = 0; i < SelectedNodeIndexes.Count; i++)
                {
                    var node = GetNetNode(SelectedNodeIndexes[i]);
                    var segment = Singleton<NetManager>.instance.m_segments.m_buffer[(int)node.m_segment0];

                    Bezier3 bezier;

                    bezier.a = node.m_position;
                    bezier.d = node.m_position;

                    var color = GetToolColor(true, false);

                    NetSegment.CalculateMiddlePoints(bezier.a, segment.m_startDirection, bezier.d,
                        segment.m_endDirection, false, false, out bezier.b, out bezier.c);
                    _renderOverlayDraw(cameraInfo, bezier, color);
                }
            }
        }

        public void _renderOverlayLaneChange(RenderManager.CameraInfo cameraInfo)
        {
            if (_hoveredSegmentIdx != 0 && _hoveredNetNodeIdx != 0 && (_hoveredSegmentIdx != _selectedSegmentIdx || _hoveredNetNodeIdx != _selectedNetNodeIdx))
            {
                var segment = Singleton<NetManager>.instance.m_segments.m_buffer[_hoveredSegmentIdx];

                NetTool.RenderOverlay(cameraInfo, ref segment, GetToolColor(false, false), GetToolColor(false, false));
            }

            if (_selectedSegmentIdx != 0)
            {
                var segment = Singleton<NetManager>.instance.m_segments.m_buffer[_selectedSegmentIdx];

                NetTool.RenderOverlay(cameraInfo, ref segment, GetToolColor(true, false), GetToolColor(true, false));
            }
        }

        public void _renderOverlayDraw(RenderManager.CameraInfo cameraInfo, Bezier3 bezier, Color color)
        {
            var width = 8f;

            ToolManager expr_EA_cp_0 = Singleton<ToolManager>.instance;
            expr_EA_cp_0.m_drawCallData.m_overlayCalls = expr_EA_cp_0.m_drawCallData.m_overlayCalls + 1;
            Singleton<RenderManager>.instance.OverlayEffect.DrawBezier(cameraInfo, color, bezier,
                width * 2f, width, width, -1f, 1280f, false, false);

            // 8 - small roads; 16 - big roads
        }

        public void _renderOverlayDraw(RenderManager.CameraInfo cameraInfo, Color color, Vector3 position, float width, bool alpha)
        {
            ToolManager expr_EA_cp_0 = Singleton<ToolManager>.instance;
            expr_EA_cp_0.m_drawCallData.m_overlayCalls = expr_EA_cp_0.m_drawCallData.m_overlayCalls + 1;
            Singleton<RenderManager>.instance.OverlayEffect.DrawCircle(cameraInfo, color, position, width, position.y - 100f, position.y + 100f, false, alpha);
        }

        public override void SimulationStep()
        {
            base.SimulationStep();

            var mouseRayValid = !UIView.IsInsideUI() && Cursor.visible;

            if (mouseRayValid)
            {
                var mouseRay = Camera.main.ScreenPointToRay(Input.mousePosition);
                var mouseRayLength = Camera.main.farClipPlane;
                var rayRight = Camera.main.transform.TransformDirection(Vector3.right);

                var defaultService = new ToolBase.RaycastService(ItemClass.Service.None, ItemClass.SubService.None, ItemClass.Layer.Default);
                var input = new ToolBase.RaycastInput(mouseRay, mouseRayLength)
                {
                    m_rayRight = rayRight,
                    m_netService = defaultService,
                    m_ignoreNodeFlags = NetNode.Flags.None,
                    m_ignoreSegmentFlags = NetSegment.Flags.Untouchable
                };
                RaycastOutput output;
                if (!RayCast(input, out output))
                {
                    //TODO: Fehlerbehandlung?
                    _hoveredSegmentIdx = 0;
                    _hoveredNetNodeIdx = 0;
                    return;
                }

                var node = GetNetNode(output.m_netNode);

                if ((node.m_flags & NetNode.Flags.Junction) != NetNode.Flags.None)
                {
                    _hoveredNetNodeIdx = output.m_netNode;
                }
                else
                {
                    _hoveredNetNodeIdx = 0;
                }

                _hoveredSegmentIdx = output.m_netSegment;
            }


            if (_toolMode == ToolMode.None)
            {
                ToolCursor = null;
            }
            else if (_toolMode == ToolMode.SwitchTrafficLight)
            {
                NetTool netTool = null;

                foreach (var tool in ToolsModifierControl.toolController.Tools)
                {
                    NetTool nt = tool as NetTool;
                    if (nt != null && nt.m_prefab != null)
                    {
                        netTool = nt;
                        break;
                    }
                }

                if (netTool != null)
                {
                    ToolCursor = netTool.m_upgradeCursor;
                }
            }
        }

        protected override void OnToolUpdate()
        {
            _mouseDown = Input.GetMouseButton(0);

            if (_mouseDown)
            {
                if (!_mouseClicked)
                {
                    _mouseClicked = true;

                    if (m_toolController.IsInsideUI || !Cursor.visible)
                    {
                        return;
                    }

                    if (_hoveredNetNodeIdx != 0)
                    {
                        var node = GetNetNode(_hoveredNetNodeIdx);

                        if (_toolMode == ToolMode.SwitchTrafficLight)
                        {
                            _switchTrafficLights();
                        }
                        else if (_toolMode == ToolMode.AddPrioritySigns)
                        {
                            if ((node.m_flags & NetNode.Flags.TrafficLights) == NetNode.Flags.None)
                            {
                                uiClickedSegment = true;
                                _selectedNetNodeIdx = _hoveredNetNodeIdx;
                            }
                            else
                            {
                                ShowToolInfo(true, "Node should not be a traffic light", node.m_position);
                            }
                        }
                        else if (_toolMode == ToolMode.ManualSwitch)
                        {
                            if (_selectedNetNodeIdx == 0)
                            {
                                if (!TrafficLightsTimed.IsTimedLight(_hoveredNetNodeIdx))
                                {
                                    if ((node.m_flags & NetNode.Flags.TrafficLights) != NetNode.Flags.None)
                                    {
                                        _selectedNetNodeIdx = _hoveredNetNodeIdx;

                                        var node2 = GetNetNode(_selectedNetNodeIdx);
                                        var nodeSimulation = CustomRoadAI.GetNodeSimulation(_selectedNetNodeIdx);

                                        CustomRoadAI.AddNodeToSimulation(_selectedNetNodeIdx);
                                        nodeSimulation = CustomRoadAI.GetNodeSimulation(_selectedNetNodeIdx);
                                        nodeSimulation.FlagManualTrafficLights = true;

                                        for (int s = 0; s < node2.CountSegments(); s++)
                                        {
                                            var segment = node2.GetSegment(s);

                                            if (segment != 0 && !TrafficPriority.isPrioritySegment(_selectedNetNodeIdx, segment))
                                            {
                                                TrafficPriority.addPrioritySegment(_selectedNetNodeIdx, segment, PrioritySegment.PriorityType.None);
                                            }
                                        }
                                    }
                                    else
                                    {
                                        ShowToolInfo(true, "Node is not a traffic light", node.m_position);
                                    }
                                }
                                else
                                {
                                    if (SelectedNodeIndexes.Count == 0)
                                    {
                                        
                                    }
                                    ShowToolInfo(true, "Node is part of timed script", node.m_position);
                                }
                            }
                        }
                        else if (_toolMode == ToolMode.TimedLightsSelectNode)
                        {
                            if (!TrafficLightsTimed.IsTimedLight(_hoveredNetNodeIdx))
                            {
                                if ((node.m_flags & NetNode.Flags.TrafficLights) != NetNode.Flags.None)
                                {
                                    if (containsListNode(_hoveredNetNodeIdx))
                                    {
                                        removeListNode(_hoveredNetNodeIdx);
                                    }
                                    else
                                    {
                                        addListNode(_hoveredNetNodeIdx);
                                    }
                                }
                                else
                                {
                                    ShowToolInfo(true, "Node is not a traffic light", node.m_position);
                                }
                            }
                            else
                            {
                                if (SelectedNodeIndexes.Count == 0)
                                {
                                    var timedLight = TrafficLightsTimed.GetTimedLight(_hoveredNetNodeIdx);

                                    SelectedNodeIndexes = new List<ushort>(timedLight.nodeGroup);
                                    setToolMode(ToolMode.TimedLightsShowLights);
                                }
                                else
                                {
                                    ShowToolInfo(true, "Node is part of timed script", node.m_position);
                                }
                            }
                        }
                        else if (_toolMode == ToolMode.LaneChange)
                        {
                            if (_hoveredNetNodeIdx != 0)
                            {
                                _selectedSegmentIdx = _hoveredSegmentIdx;
                                _selectedNetNodeIdx = _hoveredNetNodeIdx;
                            }
                        }
                    }
                    else
                    {
                        //hideUI();
                    }
                }
            }
            else
            {
                ShowToolInfo(false, null, Vector3.zero);
                _mouseClicked = false;
            }
        }

        protected override void OnToolGUI()
        {
            if (!Input.GetMouseButtonDown(0))
            {
                uiClickedSegment = false;
            }

            if (_toolMode == ToolMode.AddPrioritySigns)
            {
                _guiPrioritySigns();
            }
            else if (_toolMode == ToolMode.ManualSwitch)
            {
                _guiManualTrafficLights();
            }
            else if (_toolMode == ToolMode.TimedLightsSelectNode)
            {
                _guiTimedTrafficLightsNode();
            }
            else if (_toolMode == ToolMode.TimedLightsShowLights)
            {
                _guiTimedTrafficLights();
            }
            else if (_toolMode == ToolMode.LaneChange)
            {
                _guiLaneChange();
            }
        }

        protected void _guiManualTrafficLights()
        {
            var hoveredSegment = false;

            if (_selectedNetNodeIdx != 0)
            {
                var node = GetNetNode(_selectedNetNodeIdx);

                var segmentId = 0;

                var nodeSimulation = CustomRoadAI.GetNodeSimulation(_selectedNetNodeIdx);

                for (var i = 0; i < 8; i++)
                {
                    segmentId = node.GetSegment(i);

                    if (segmentId != 0 && nodeSimulation != null && TrafficLightsManual.IsSegmentLight(_selectedNetNodeIdx, segmentId))
                    {
                        var segmentDict = TrafficLightsManual.GetSegmentLight(_selectedNetNodeIdx, segmentId);

                        var segment = Singleton<NetManager>.instance.m_segments.m_buffer[(int)segmentId];

                        var position = node.m_position;

                        var offset = 25f;

                        if (segment.m_startNode == _selectedNetNodeIdx)
                        {
                            position.x += segment.m_startDirection.x * offset;
                            position.y += segment.m_startDirection.y * offset;
                            position.z += segment.m_startDirection.z * offset;
                        }
                        else
                        {
                            position.x += segment.m_endDirection.x * offset;
                            position.y += segment.m_endDirection.y * offset;
                            position.z += segment.m_endDirection.z * offset;
                        }

                        var guiColor = GUI.color;

                        var screenPos = Camera.main.WorldToScreenPoint(position);
                        screenPos.y = Screen.height - screenPos.y;

                        Vector3 diff = position - Camera.main.transform.position;
                        float zoom = 1.0f/diff.magnitude*100f;

                        // original / 2.5
                        var lightWidth = 41f*zoom;
                        var lightHeight = 97f*zoom;

                        // SWITCH MODE BUTTON
                        var modeWidth = 41f*zoom;
                        var modeHeight = 38f*zoom;
                                    

                        guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == -1 ? 0.92f : 0.45f;

                        GUI.color = guiColor;

                        Rect myRect1 = new Rect(screenPos.x - modeWidth / 2, screenPos.y - modeHeight / 2 + modeHeight - 7f*zoom, modeWidth, modeHeight);

                        GUI.DrawTexture(myRect1, light_mode);

                        if (myRect1.Contains(Event.current.mousePosition))
                        {
                            _hoveredButton[0] = segmentId;
                            _hoveredButton[1] = -1;
                            hoveredSegment = true;

                            if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                            {
                                uiClickedSegment = true;
                                segmentDict.ChangeMode();
                            }
                        }

                        // COUNTER
                        guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 0 ? 0.92f : 0.45f;

                        GUI.color = guiColor;

                        Rect myRectCounter = new Rect(screenPos.x - modeWidth / 2, screenPos.y - modeHeight / 2 - 6f*zoom, modeWidth, modeHeight);

                        GUI.DrawTexture(myRectCounter, light_counter);

                        float counterSize = 20f * zoom;

                        var counter = segmentDict.lastChange;

                        Rect myRectCounterNum = new Rect(screenPos.x - counterSize + 15f * zoom + (counter >= 10 ? -5*zoom : 0f), screenPos.y - counterSize + 11f * zoom, counterSize, counterSize);

                        counterStyle.fontSize = (int)(18f*zoom);
                        counterStyle.normal.textColor = new Color(1f, 1f, 1f);

                        GUI.Label(myRectCounterNum, counter.ToString(), counterStyle);

                        if (myRectCounter.Contains(Event.current.mousePosition))
                        {
                            _hoveredButton[0] = segmentId;
                            _hoveredButton[1] = 0;
                            hoveredSegment = true;
                        }

                        // SWITCH MANUAL PEDESTRIAN LIGHT BUTTON
                        var manualPedestrianWidth = 36f*zoom;
                        var manualPedestrianHeight = 35f*zoom;

                        guiColor.a = _hoveredButton[0] == segmentId && (_hoveredButton[1] == 1 || _hoveredButton[1] == 2) ? 0.92f : 0.45f;

                        GUI.color = guiColor;

                        Rect myRect2 = new Rect(screenPos.x - manualPedestrianWidth / 2 - lightWidth + 5f*zoom, screenPos.y - manualPedestrianHeight / 2 - 9f*zoom, manualPedestrianWidth, manualPedestrianHeight);

                        if (segmentDict.pedestrianEnabled)
                            GUI.DrawTexture(myRect2, pedestrian_mode_2);
                        else
                            GUI.DrawTexture(myRect2, pedestrian_mode_1);

                        if (myRect2.Contains(Event.current.mousePosition))
                        {
                            _hoveredButton[0] = segmentId;
                            _hoveredButton[1] = 1;
                            hoveredSegment = true;

                            if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                            {
                                uiClickedSegment = true;
                                segmentDict.ManualPedestrian();
                            }
                        }

                        // SWITCH PEDESTRIAN LIGHT
                        var pedestrianWidth = 36f * zoom;
                        var pedestrianHeight = 61f * zoom;

                        guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 2 && segmentDict.pedestrianEnabled ? 0.92f : 0.45f;

                        GUI.color = guiColor;

                        Rect myRect3 = new Rect(screenPos.x - pedestrianWidth / 2 - lightWidth + 5f*zoom, screenPos.y - pedestrianHeight / 2 + 22f*zoom, pedestrianWidth, pedestrianHeight);

                        if (segmentDict.lightPedestrian == RoadBaseAI.TrafficLightState.Green)
                            GUI.DrawTexture(myRect3, pedestrian_light_2);
                        else if (segmentDict.lightPedestrian == RoadBaseAI.TrafficLightState.Red)
                            GUI.DrawTexture(myRect3, pedestrian_light_1);

                        if (myRect3.Contains(Event.current.mousePosition))
                        {
                            _hoveredButton[0] = segmentId;
                            _hoveredButton[1] = 2;
                            hoveredSegment = true;

                            if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                            {
                                uiClickedSegment = true;

                                if (!segmentDict.pedestrianEnabled)
                                {
                                    segmentDict.ManualPedestrian();
                                }
                                else
                                {
                                    segmentDict.ChangeLightPedestrian();
                                }
                            }
                        }

                        if (!TrafficLightsManual.segmentIsOneWay(segmentId))
                        {
                            var hasLeftSegment = TrafficPriority.HasLeftSegment(segmentId, _selectedNetNodeIdx, false);
                            var hasForwardSegment = TrafficPriority.HasForwardSegment(segmentId, _selectedNetNodeIdx, false);
                            var hasRightSegment = TrafficPriority.HasRightSegment(segmentId, _selectedNetNodeIdx, false);

                            if (segmentDict.currentMode == ManualSegmentLight.Mode.Simple)
                            {
                                // no arrow light
                                guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 3 ? 0.92f : 0.45f;

                                GUI.color = guiColor;

                                Rect myRect4 =
                                    new Rect(screenPos.x - lightWidth/2 - lightWidth - pedestrianWidth + 5f*zoom,
                                        screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                    GUI.DrawTexture(myRect4, light_simple_3);
                                else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                    GUI.DrawTexture(myRect4, light_simple_1);

                                if (myRect4.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 3;
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;
                                        segmentDict.ChangeLightMain();
                                    }
                                }
                            }
                            else if (segmentDict.currentMode == ManualSegmentLight.Mode.LeftForwardR)
                            {
                                if (hasLeftSegment)
                                {
                                    // left arrow light
                                    guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 3 ? 0.92f : 0.45f;

                                    GUI.color = guiColor;

                                    Rect myRect4 =
                                        new Rect(screenPos.x - lightWidth/2 - lightWidth*2 - pedestrianWidth + 5f*zoom,
                                            screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                    if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect4, light_left_3);
                                    else if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect4, light_left_1);

                                    if (myRect4.Contains(Event.current.mousePosition))
                                    {
                                        _hoveredButton[0] = segmentId;
                                        _hoveredButton[1] = 3;
                                        hoveredSegment = true;

                                        if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                        {
                                            uiClickedSegment = true;
                                            segmentDict.ChangeLightLeft();
                                        }
                                    }
                                }

                                // forward-right arrow light
                                guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 4 ? 0.92f : 0.45f;

                                GUI.color = guiColor;

                                Rect myRect5 =
                                    new Rect(screenPos.x - lightWidth/2 - lightWidth - pedestrianWidth + 5f*zoom,
                                        screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                if (hasForwardSegment && hasRightSegment)
                                {
                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect5, light_forwardright_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect5, light_forwardright_1);
                                }
                                else if (!hasRightSegment)
                                {
                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect5, light_forward_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect5, light_forward_1);
                                }
                                else
                                {
                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect5, light_right_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect5, light_right_1);
                                }

                                if (myRect5.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 4;
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;
                                        segmentDict.ChangeLightMain();
                                    }
                                }
                            }
                            else if (segmentDict.currentMode == ManualSegmentLight.Mode.RightForwardL)
                            {
                                // forward-left light
                                guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 3 ? 0.92f : 0.45f;

                                GUI.color = guiColor;

                                Rect myRect4 = new Rect(screenPos.x - lightWidth/2 - lightWidth*2 - pedestrianWidth + 5f*zoom,
                                        screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                if (hasForwardSegment && hasLeftSegment)
                                {
                                    if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect4, light_forwardleft_3);
                                    else if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect4, light_forwardleft_1);
                                }
                                else if (!hasLeftSegment)
                                {
                                    if (!hasRightSegment)
                                    {
                                        myRect4 = new Rect(screenPos.x - lightWidth / 2 - lightWidth - pedestrianWidth + 5f * zoom,
                                        screenPos.y - lightHeight / 2, lightWidth, lightHeight);
                                    }

                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect4, light_forward_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect4, light_forward_1);
                                }
                                else
                                {
                                    if (!hasRightSegment)
                                    {
                                        myRect4 = new Rect(screenPos.x - lightWidth / 2 - lightWidth - pedestrianWidth + 5f * zoom,
                                        screenPos.y - lightHeight / 2, lightWidth, lightHeight);
                                    }

                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect4, light_left_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect4, light_left_1);
                                }


                                if (myRect4.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 3;
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;
                                        segmentDict.ChangeLightMain();
                                    }
                                }

                                // right arrow light
                                if (hasRightSegment)
                                guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 4 ? 0.92f : 0.45f;

                                GUI.color = guiColor;

                                Rect myRect5 =
                                    new Rect(screenPos.x - lightWidth/2 - lightWidth - pedestrianWidth + 5f*zoom,
                                        screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                if (segmentDict.lightRight == RoadBaseAI.TrafficLightState.Green)
                                    GUI.DrawTexture(myRect5, light_right_3);
                                else if (segmentDict.lightRight == RoadBaseAI.TrafficLightState.Red)
                                    GUI.DrawTexture(myRect5, light_right_1);


                                if (myRect5.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 4;
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;
                                        segmentDict.ChangeLightRight();
                                    }
                                }
                            }
                            else // all
                            {
                                // left arrow light
                                if (hasLeftSegment)
                                {
                                    guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 3 ? 0.92f : 0.45f;

                                    GUI.color = guiColor;

                                    var offsetLight = lightWidth;

                                    if (hasRightSegment)
                                        offsetLight += lightWidth;

                                    if (hasForwardSegment)
                                        offsetLight += lightWidth;

                                    Rect myRect4 =
                                        new Rect(screenPos.x - lightWidth / 2 - offsetLight - pedestrianWidth + 5f * zoom,
                                            screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                    if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect4, light_left_3);
                                    else if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect4, light_left_1);

                                    if (myRect4.Contains(Event.current.mousePosition))
                                    {
                                        _hoveredButton[0] = segmentId;
                                        _hoveredButton[1] = 3;
                                        hoveredSegment = true;

                                        if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                        {
                                            uiClickedSegment = true;
                                            segmentDict.ChangeLightLeft();
                                        }
                                    }
                                }

                                // forward arrow light
                                if (hasForwardSegment)
                                {
                                    guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 4 ? 0.92f : 0.45f;

                                    GUI.color = guiColor;

                                    var offsetLight = lightWidth;

                                    if (hasRightSegment)
                                        offsetLight += lightWidth;

                                    Rect myRect6 =
                                        new Rect(screenPos.x - lightWidth/2 - offsetLight - pedestrianWidth + 5f*zoom,
                                            screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect6, light_forward_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect6, light_forward_1);

                                    if (myRect6.Contains(Event.current.mousePosition))
                                    {
                                        _hoveredButton[0] = segmentId;
                                        _hoveredButton[1] = 4;
                                        hoveredSegment = true;

                                        if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                        {
                                            uiClickedSegment = true;
                                            segmentDict.ChangeLightMain();
                                        }
                                    }
                                }

                                // right arrow light
                                if (hasRightSegment)
                                {
                                    guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 5 ? 0.92f : 0.45f;

                                    GUI.color = guiColor;

                                    Rect myRect5 =
                                        new Rect(screenPos.x - lightWidth/2 - lightWidth - pedestrianWidth + 5f*zoom,
                                            screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                    if (segmentDict.lightRight == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect5, light_right_3);
                                    else if (segmentDict.lightRight == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect5, light_right_1);

                                    if (myRect5.Contains(Event.current.mousePosition))
                                    {
                                        _hoveredButton[0] = segmentId;
                                        _hoveredButton[1] = 5;
                                        hoveredSegment = true;

                                        if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                        {
                                            uiClickedSegment = true;
                                            segmentDict.ChangeLightRight();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (!hoveredSegment)
            {
                _hoveredButton[0] = 0;
                _hoveredButton[1] = 0;
            }
        }

        protected void _guiTimedTrafficLights()
        {
            GUILayout.Window(0, _windowRect, _guiTimedControlPanel, "Timed traffic lights manager");
            var hoveredSegment = false;

            for (var i2 = 0; i2 < SelectedNodeIndexes.Count; i2++)
            {
                var node = GetNetNode(SelectedNodeIndexes[i2]);

                var segmentId = 0;

                var nodeSimulation = CustomRoadAI.GetNodeSimulation(SelectedNodeIndexes[i2]);

                for (var i = 0; i < 8; i++)
                {
                    segmentId = node.GetSegment(i);

                    if (segmentId != 0 && nodeSimulation != null && TrafficLightsManual.IsSegmentLight(SelectedNodeIndexes[i2], segmentId))
                    {
                        var segmentDict = TrafficLightsManual.GetSegmentLight(SelectedNodeIndexes[i2], segmentId);

                        var segment = Singleton<NetManager>.instance.m_segments.m_buffer[(int)segmentId];

                        var position = node.m_position;

                        var offset = 25f;

                        if (segment.m_startNode == SelectedNodeIndexes[i2])
                        {
                            position.x += segment.m_startDirection.x * offset;
                            position.y += segment.m_startDirection.y * offset;
                            position.z += segment.m_startDirection.z * offset;
                        }
                        else
                        {
                            position.x += segment.m_endDirection.x * offset;
                            position.y += segment.m_endDirection.y * offset;
                            position.z += segment.m_endDirection.z * offset;
                        }

                        var guiColor = GUI.color;

                        var screenPos = Camera.main.WorldToScreenPoint(position);
                        screenPos.y = Screen.height - screenPos.y;

                        Vector3 diff = position - Camera.main.transform.position;
                        float zoom = 1.0f/diff.magnitude*100f;

                        var timedActive = nodeSimulation.TimedTrafficLightsActive;

                        // original / 2.5
                        var lightWidth = 41f*zoom;
                        var lightHeight = 97f*zoom;

                        // SWITCH MODE BUTTON
                        var modeWidth = 41f*zoom;
                        var modeHeight = 38f*zoom;

                        if (!timedActive)
                        {
                            guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == -1 &&
                                         _hoveredNode == SelectedNodeIndexes[i2]
                                ? 0.92f
                                : 0.45f;

                            GUI.color = guiColor;

                            Rect myRect1 = new Rect(screenPos.x - modeWidth/2,
                                screenPos.y - modeHeight/2 + modeHeight - 7f*zoom, modeWidth, modeHeight);

                            GUI.DrawTexture(myRect1, light_mode);

                            if (myRect1.Contains(Event.current.mousePosition))
                            {
                                _hoveredButton[0] = segmentId;
                                _hoveredButton[1] = -1;
                                _hoveredNode = SelectedNodeIndexes[i2];
                                hoveredSegment = true;

                                if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                {
                                    uiClickedSegment = true;
                                    segmentDict.ChangeMode();
                                }
                            }
                        }

                        // COUNTER
                        guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 0 && _hoveredNode == SelectedNodeIndexes[i2] ? 0.92f : 0.45f;

                        GUI.color = guiColor;

                        Rect myRectCounter = new Rect(screenPos.x - modeWidth / 2, screenPos.y - modeHeight / 2 - 6f*zoom, modeWidth, modeHeight);

                        GUI.DrawTexture(myRectCounter, light_counter);

                        float counterSize = 20f * zoom;

                        var counter = segmentDict.lastChange;

                        Rect myRectCounterNum = new Rect(screenPos.x - counterSize + 15f * zoom + (counter >= 10 ? -5*zoom : 0f), screenPos.y - (timedActive ?  modeHeight/2 + modeHeight - 7f*zoom : counterSize + 11f * zoom), counterSize, counterSize);

                        counterStyle.fontSize = (int)(18f*zoom);
                        counterStyle.normal.textColor = new Color(1f, 1f, 1f);

                        GUI.Label(myRectCounterNum, counter.ToString(), counterStyle);

                        if (myRectCounter.Contains(Event.current.mousePosition))
                        {
                            _hoveredButton[0] = segmentId;
                            _hoveredButton[1] = 0;
                            _hoveredNode = SelectedNodeIndexes[i2];
                            hoveredSegment = true;
                        }

                        // SWITCH MANUAL PEDESTRIAN LIGHT BUTTON
                        var manualPedestrianWidth = 36f*zoom;
                        var manualPedestrianHeight = 35f*zoom;

                        if (!timedActive)
                        {
                            guiColor.a = _hoveredButton[0] == segmentId &&
                                         (_hoveredButton[1] == 1 || _hoveredButton[1] == 2) &&
                                         _hoveredNode == SelectedNodeIndexes[i2]
                                ? 0.92f
                                : 0.45f;

                            GUI.color = guiColor;

                            Rect myRect2 = new Rect(screenPos.x - manualPedestrianWidth/2 - lightWidth + 5f*zoom,
                                screenPos.y - manualPedestrianHeight/2 - 9f*zoom, manualPedestrianWidth,
                                manualPedestrianHeight);

                            if (segmentDict.pedestrianEnabled)
                                GUI.DrawTexture(myRect2, pedestrian_mode_2);
                            else
                                GUI.DrawTexture(myRect2, pedestrian_mode_1);

                            if (myRect2.Contains(Event.current.mousePosition))
                            {
                                _hoveredButton[0] = segmentId;
                                _hoveredButton[1] = 1;
                                _hoveredNode = SelectedNodeIndexes[i2];
                                hoveredSegment = true;

                                if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                {
                                    uiClickedSegment = true;
                                    segmentDict.ManualPedestrian();
                                }
                            }
                        }

                        // SWITCH PEDESTRIAN LIGHT
                        var pedestrianWidth = 36f * zoom;
                        var pedestrianHeight = 61f * zoom;

                        guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 2 && segmentDict.pedestrianEnabled && _hoveredNode == SelectedNodeIndexes[i2] ? 0.92f : 0.45f;

                        GUI.color = guiColor;

                        Rect myRect3 = new Rect(screenPos.x - pedestrianWidth / 2 - lightWidth + 5f*zoom, screenPos.y - pedestrianHeight / 2 + 22f*zoom, pedestrianWidth, pedestrianHeight);

                        if (segmentDict.lightPedestrian == RoadBaseAI.TrafficLightState.Green)
                            GUI.DrawTexture(myRect3, pedestrian_light_2);
                        else if (segmentDict.lightPedestrian == RoadBaseAI.TrafficLightState.Red)
                            GUI.DrawTexture(myRect3, pedestrian_light_1);

                        if (myRect3.Contains(Event.current.mousePosition))
                        {
                            _hoveredButton[0] = segmentId;
                            _hoveredButton[1] = 2;
                            _hoveredNode = SelectedNodeIndexes[i2];
                            hoveredSegment = true;

                            if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                            {
                                uiClickedSegment = true;

                                if (!segmentDict.pedestrianEnabled)
                                {
                                    segmentDict.ManualPedestrian();
                                }
                                else
                                {
                                    segmentDict.ChangeLightPedestrian();
                                }
                            }
                        }

                        if (!TrafficLightsManual.segmentIsOneWay(segmentId))
                        {
                            var hasLeftSegment = TrafficPriority.HasLeftSegment(segmentId, SelectedNodeIndexes[i2], false);
                            var hasForwardSegment = TrafficPriority.HasForwardSegment(segmentId, SelectedNodeIndexes[i2], false);
                            var hasRightSegment = TrafficPriority.HasRightSegment(segmentId, SelectedNodeIndexes[i2], false);

                            if (segmentDict.currentMode == ManualSegmentLight.Mode.Simple)
                            {
                                // no arrow light
                                guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 3 && _hoveredNode == SelectedNodeIndexes[i2] ? 0.92f : 0.45f;

                                GUI.color = guiColor;

                                Rect myRect4 =
                                    new Rect(screenPos.x - lightWidth/2 - lightWidth - pedestrianWidth + 5f*zoom,
                                        screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                    GUI.DrawTexture(myRect4, light_simple_3);
                                else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                    GUI.DrawTexture(myRect4, light_simple_1);

                                if (myRect4.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 3;
                                    _hoveredNode = SelectedNodeIndexes[i2];
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;
                                        segmentDict.ChangeLightMain();
                                    }
                                }
                            }
                            else if (segmentDict.currentMode == ManualSegmentLight.Mode.LeftForwardR)
                            {
                                if (hasLeftSegment)
                                {
                                    // left arrow light
                                    guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 3 && _hoveredNode == SelectedNodeIndexes[i2] ? 0.92f : 0.45f;

                                    GUI.color = guiColor;

                                    Rect myRect4 =
                                        new Rect(screenPos.x - lightWidth/2 - lightWidth*2 - pedestrianWidth + 5f*zoom,
                                            screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                    if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect4, light_left_3);
                                    else if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect4, light_left_1);

                                    if (myRect4.Contains(Event.current.mousePosition))
                                    {
                                        _hoveredButton[0] = segmentId;
                                        _hoveredButton[1] = 3;
                                        _hoveredNode = SelectedNodeIndexes[i2];
                                        hoveredSegment = true;

                                        if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                        {
                                            uiClickedSegment = true;
                                            segmentDict.ChangeLightLeft();
                                        }
                                    }
                                }

                                // forward-right arrow light
                                guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 4 && _hoveredNode == SelectedNodeIndexes[i2] ? 0.92f : 0.45f;

                                GUI.color = guiColor;

                                Rect myRect5 =
                                    new Rect(screenPos.x - lightWidth/2 - lightWidth - pedestrianWidth + 5f*zoom,
                                        screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                if (hasForwardSegment && hasRightSegment)
                                {
                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect5, light_forwardright_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect5, light_forwardright_1);
                                }
                                else if (!hasRightSegment)
                                {
                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect5, light_forward_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect5, light_forward_1);
                                }
                                else
                                {
                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect5, light_right_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect5, light_right_1);
                                }

                                if (myRect5.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 4;
                                    _hoveredNode = SelectedNodeIndexes[i2];
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;
                                        segmentDict.ChangeLightMain();
                                    }
                                }
                            }
                            else if (segmentDict.currentMode == ManualSegmentLight.Mode.RightForwardL)
                            {
                                // forward-left light
                                guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 3 && _hoveredNode == SelectedNodeIndexes[i2] ? 0.92f : 0.45f;

                                GUI.color = guiColor;

                                Rect myRect4 = new Rect(screenPos.x - lightWidth/2 - lightWidth*2 - pedestrianWidth + 5f*zoom,
                                        screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                if (hasForwardSegment && hasLeftSegment)
                                {
                                    if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect4, light_forwardleft_3);
                                    else if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect4, light_forwardleft_1);
                                }
                                else if (!hasLeftSegment)
                                {
                                    if (!hasRightSegment)
                                    {
                                        myRect4 = new Rect(screenPos.x - lightWidth / 2 - lightWidth - pedestrianWidth + 5f * zoom,
                                        screenPos.y - lightHeight / 2, lightWidth, lightHeight);
                                    }

                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect4, light_forward_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect4, light_forward_1);
                                }
                                else
                                {
                                    if (!hasRightSegment)
                                    {
                                        myRect4 = new Rect(screenPos.x - lightWidth / 2 - lightWidth - pedestrianWidth + 5f * zoom,
                                        screenPos.y - lightHeight / 2, lightWidth, lightHeight);
                                    }

                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect4, light_left_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect4, light_left_1);
                                }


                                if (myRect4.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 3;
                                    _hoveredNode = SelectedNodeIndexes[i2];
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;
                                        segmentDict.ChangeLightMain();
                                    }
                                }

                                // right arrow light
                                if (hasRightSegment)
                                    guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 4 && _hoveredNode == SelectedNodeIndexes[i2] ? 0.92f : 0.45f;

                                GUI.color = guiColor;

                                Rect myRect5 =
                                    new Rect(screenPos.x - lightWidth/2 - lightWidth - pedestrianWidth + 5f*zoom,
                                        screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                if (segmentDict.lightRight == RoadBaseAI.TrafficLightState.Green)
                                    GUI.DrawTexture(myRect5, light_right_3);
                                else if (segmentDict.lightRight == RoadBaseAI.TrafficLightState.Red)
                                    GUI.DrawTexture(myRect5, light_right_1);


                                if (myRect5.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 4;
                                    _hoveredNode = SelectedNodeIndexes[i2];
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;
                                        segmentDict.ChangeLightRight();
                                    }
                                }
                            }
                            else // all
                            {
                                // left arrow light
                                if (hasLeftSegment)
                                {
                                    guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 3 && _hoveredNode == SelectedNodeIndexes[i2] ? 0.92f : 0.45f;

                                    GUI.color = guiColor;

                                    var offsetLight = lightWidth;

                                    if (hasRightSegment)
                                        offsetLight += lightWidth;

                                    if (hasForwardSegment)
                                        offsetLight += lightWidth;

                                    Rect myRect4 =
                                        new Rect(screenPos.x - lightWidth / 2 - offsetLight - pedestrianWidth + 5f * zoom,
                                            screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                    if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect4, light_left_3);
                                    else if (segmentDict.lightLeft == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect4, light_left_1);

                                    if (myRect4.Contains(Event.current.mousePosition))
                                    {
                                        _hoveredButton[0] = segmentId;
                                        _hoveredButton[1] = 3;
                                        _hoveredNode = SelectedNodeIndexes[i2];
                                        hoveredSegment = true;

                                        if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                        {
                                            uiClickedSegment = true;
                                            segmentDict.ChangeLightLeft();
                                        }
                                    }
                                }

                                // forward arrow light
                                if (hasForwardSegment)
                                {
                                    guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 4 && _hoveredNode == SelectedNodeIndexes[i2] ? 0.92f : 0.45f;

                                    GUI.color = guiColor;

                                    var offsetLight = lightWidth;

                                    if (hasRightSegment)
                                        offsetLight += lightWidth;

                                    Rect myRect6 =
                                        new Rect(screenPos.x - lightWidth/2 - offsetLight - pedestrianWidth + 5f*zoom,
                                            screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                    if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect6, light_forward_3);
                                    else if (segmentDict.lightMain == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect6, light_forward_1);

                                    if (myRect6.Contains(Event.current.mousePosition))
                                    {
                                        _hoveredButton[0] = segmentId;
                                        _hoveredButton[1] = 4;
                                        _hoveredNode = SelectedNodeIndexes[i2];
                                        hoveredSegment = true;

                                        if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                        {
                                            uiClickedSegment = true;
                                            segmentDict.ChangeLightMain();
                                        }
                                    }
                                }

                                // right arrow light
                                if (hasRightSegment)
                                {
                                    guiColor.a = _hoveredButton[0] == segmentId && _hoveredButton[1] == 5 && _hoveredNode == SelectedNodeIndexes[i2] ? 0.92f : 0.45f;

                                    GUI.color = guiColor;

                                    Rect myRect5 =
                                        new Rect(screenPos.x - lightWidth/2 - lightWidth - pedestrianWidth + 5f*zoom,
                                            screenPos.y - lightHeight/2, lightWidth, lightHeight);

                                    if (segmentDict.lightRight == RoadBaseAI.TrafficLightState.Green)
                                        GUI.DrawTexture(myRect5, light_right_3);
                                    else if (segmentDict.lightRight == RoadBaseAI.TrafficLightState.Red)
                                        GUI.DrawTexture(myRect5, light_right_1);

                                    if (myRect5.Contains(Event.current.mousePosition))
                                    {
                                        _hoveredButton[0] = segmentId;
                                        _hoveredButton[1] = 5;
                                        _hoveredNode = SelectedNodeIndexes[i2];
                                        hoveredSegment = true;

                                        if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                        {
                                            uiClickedSegment = true;
                                            segmentDict.ChangeLightRight();
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }

            if (!hoveredSegment)
            {
                _hoveredButton[0] = 0;
                _hoveredButton[1] = 0;
            }
        }

        protected void _guiLaneChange()
        {
            if (_selectedNetNodeIdx != 0 && _selectedSegmentIdx != 0)
            {
                var segment = Singleton<NetManager>.instance.m_segments.m_buffer[_selectedSegmentIdx];
                
                var info = segment.Info;
                uint num2 = segment.m_lanes;
                int num3 = 0;

                NetInfo.Direction dir = NetInfo.Direction.Forward;
                if (segment.m_startNode == TrafficLightTool.SelectedNode)
                    dir = NetInfo.Direction.Backward;
                var dir2 = ((segment.m_flags & NetSegment.Flags.Invert) == NetSegment.Flags.None) ? dir : NetInfo.InvertDirection(dir);

                var numLanes = 0;

                while (num3 < info.m_lanes.Length && num2 != 0u)
                {
                    if (info.m_lanes[num3].m_laneType != NetInfo.LaneType.Pedestrian &&
                        info.m_lanes[num3].m_direction == dir2)
                    {
                        numLanes++;
                    }

                    num2 = Singleton<NetManager>.instance.m_lanes.m_buffer[(int)((UIntPtr)num2)].m_nextLane;
                    num3++;
                }

                var style = new GUIStyle();
                style.normal.background = MakeTex(numLanes*120, 50, new Color(0.5f, 0.5f, 0.5f, 1f));
                style.alignment = TextAnchor.MiddleCenter;
                style.border.bottom = 2;
                style.border.top = 2;
                style.border.right = 2;
                style.border.left = 2;

                Rect _windowRect3 = new Rect(275, 80, numLanes * 118, 50);

                GUILayout.Window(2, _windowRect3, _guiLaneChangeWindow, "", style);

                if (_windowRect3.Contains(Event.current.mousePosition))
                {
                    //Debug.Log("Inside");
                }
            }
        }

        protected void _guiLaneChangeWindow(int num)
        {
            NetManager instance = Singleton<NetManager>.instance;

            var segment = instance.m_segments.m_buffer[_selectedSegmentIdx];

            var info = segment.Info;

            uint num2 = segment.m_lanes;
            int num3 = 0;

            List<float[]> laneList = new List<float[]>();

            NetInfo.Direction dir = NetInfo.Direction.Forward;
            if (segment.m_startNode == TrafficLightTool.SelectedNode)
                dir = NetInfo.Direction.Backward;
            var dir2 = ((segment.m_flags & NetSegment.Flags.Invert) == NetSegment.Flags.None) ? dir : NetInfo.InvertDirection(dir);

            while (num3 < info.m_lanes.Length && num2 != 0u)
            {
                if (info.m_lanes[num3].m_laneType != NetInfo.LaneType.Pedestrian &&
                    info.m_lanes[num3].m_direction == dir2)
                {
                    laneList.Add(new float[3] { num2, info.m_lanes[num3].m_position, num3 });
                }

                num2 = instance.m_lanes.m_buffer[(int)((UIntPtr)num2)].m_nextLane;
                num3++;
            }

            laneList.Sort(delegate(float[] x, float[] y)
            {
                if(Mathf.Abs(y[1]) > Mathf.Abs(x[1]))
                {
                    return -1;
                } 
                else
                {
                    return 1;
                }
            });

            GUILayout.BeginHorizontal();

            var boxstyle = new GUIStyle();
            boxstyle.fixedWidth = 69;

            for (var i = 0; i < laneList.Count; i++)
            {
                var flags = (NetLane.Flags) Singleton<NetManager>.instance.m_lanes.m_buffer[(int)laneList[i][0]].m_flags;

                var style1 = new GUIStyle("button");
                var style2 = new GUIStyle("button");
                style2.normal.textColor = new Color32(255, 0, 0, 255);

                var laneStyle = new GUIStyle();
                laneStyle.contentOffset = new Vector2(12f, 0f);

                var laneTitleStyle = new GUIStyle();
                laneTitleStyle.contentOffset = new Vector2(36f, 2f);
                laneTitleStyle.normal.textColor = new Color(1f, 1f, 1f);

                GUILayout.BeginVertical(laneStyle);
                GUILayout.Label("Lane " + (i + 1), laneTitleStyle);
                    GUILayout.BeginVertical();
                        GUILayout.BeginHorizontal();
                        if (GUILayout.Button("←", ((flags & NetLane.Flags.Left) == NetLane.Flags.Left ? style1 : style2), new GUILayoutOption[2] { GUILayout.Width(35), GUILayout.Height(25) }))
                            {
                                laneFlag((uint)laneList[i][0], NetLane.Flags.Left);
                            }
                        if (GUILayout.Button("↑", ((flags & NetLane.Flags.Forward) == NetLane.Flags.Forward ? style1 : style2), new GUILayoutOption[2] { GUILayout.Width(25), GUILayout.Height(35) }))
                            {
                                laneFlag((uint)laneList[i][0], NetLane.Flags.Forward);
                            }
                        if (GUILayout.Button("→", ((flags & NetLane.Flags.Right) == NetLane.Flags.Right ? style1 : style2), new GUILayoutOption[2] { GUILayout.Width(35), GUILayout.Height(25) }))
                            {
                                laneFlag((uint)laneList[i][0], NetLane.Flags.Right);
                            }
                        GUILayout.EndHorizontal();
                    GUILayout.EndVertical();
                GUILayout.EndVertical();
            }

            GUILayout.EndHorizontal();
        }

        public void laneFlag(uint laneID, NetLane.Flags flag)
        {
            var flags = (NetLane.Flags)Singleton<NetManager>.instance.m_lanes.m_buffer[laneID].m_flags;

            if ((flags & flag) == flag)
            {
                Singleton<NetManager>.instance.m_lanes.m_buffer[laneID].m_flags = (ushort) (flags & ~flag);
            }
            else
            {
                Singleton<NetManager>.instance.m_lanes.m_buffer[laneID].m_flags = (ushort)(flags | flag);
            }
        }

        private Texture2D MakeTex(int width, int height, Color col)
        {
            Color[] pix = new Color[width * height];

            for (int i = 0; i < pix.Length; i++)
                pix[i] = col;

            Texture2D result = new Texture2D(width, height);
            result.SetPixels(pix);
            result.Apply();

            return result;
        }

        protected void _guiTimedTrafficLightsNode()
        {
            GUILayout.Window(1, _windowRect2, _guiTimedTrafficLightsNodeWindow, "Select nodes");
        }

        protected void _guiTimedTrafficLightsNodeWindow(int num)
        {
            if (SelectedNodeIndexes.Count < 1)
            {
                GUILayout.Label("Select nodes");
            }
            else
            {
                var txt = "";

                for (var i = 0; i < SelectedNodeIndexes.Count; i++)
                {
                    txt += "Node " + SelectedNodeIndexes[i] + "\n";
                }

                GUILayout.Label(txt);

                if(GUILayout.Button("Next"))
                {
                    for (var i = 0; i < SelectedNodeIndexes.Count; i++)
                    {
                        var node2 = GetNetNode(SelectedNodeIndexes[i]);
                        var nodeSimulation = CustomRoadAI.GetNodeSimulation(SelectedNodeIndexes[i]);
                        CustomRoadAI.AddNodeToSimulation(SelectedNodeIndexes[i]);
                        nodeSimulation = CustomRoadAI.GetNodeSimulation(SelectedNodeIndexes[i]);
                        nodeSimulation.FlagTimedTrafficLights = true;

                        for (int s = 0; s < node2.CountSegments(); s++)
                        {
                            var segment = node2.GetSegment(s);

                            if (segment != 0 && !TrafficPriority.isPrioritySegment(SelectedNodeIndexes[i], segment))
                            {
                                TrafficPriority.addPrioritySegment(SelectedNodeIndexes[i], segment,
                                    PrioritySegment.PriorityType.None);
                            }
                        }
                    }

                    setToolMode(ToolMode.TimedLightsShowLights);
                }
            }
        }

        private bool timedPanelAdd = false;
        private int timedEditStep = -1;

        protected void _guiTimedControlPanel(int num)
        {
            var nodeSimulation = CustomRoadAI.GetNodeSimulation(SelectedNodeIndexes[0]);
            var timedNodeMain = TrafficLightsTimed.GetTimedLight(SelectedNodeIndexes[0]);

            for (var i = 0; i < timedNodeMain.NumSteps(); i++)
            {
                GUILayout.BeginHorizontal();

                if (timedEditStep != i)
                {
                    if (nodeSimulation.TimedTrafficLightsActive)
                    {
                        if (i == timedNodeMain.currentStep)
                        {
                            var layout = new GUIStyle();
                            layout.normal.textColor = new Color(0.3f, 0.3f, 0.3f);

                            GUILayout.Label("State " + (i + 1) + ": " + timedNodeMain.GetStep(i).currentStep() + " - " +
                                            timedNodeMain.GetStep(i), layout);
                        }
                        else
                        {
                            GUILayout.Label("State " + (i + 1) + ": " + timedNodeMain.GetStep(i).numSteps);
                        }
                    }
                    else
                    {
                        GUILayout.Label("State " + (i + 1) + ": " + timedNodeMain.GetStep(i).numSteps);
                        if (GUILayout.Button("Edit", GUILayout.Width(45)))
                        {
                            timedEditStep = i;
                            stepValue = timedNodeMain.GetStep(i).numSteps;
                        }

                        if (GUILayout.Button("Delete", GUILayout.Width(60)))
                        {
                            for (var s = 0; s < SelectedNodeIndexes.Count; s++)
                            {
                                var timeNode = TrafficLightsTimed.GetTimedLight(SelectedNodeIndexes[s]);
                                timeNode.RemoveStep(s);
                            }
                        }
                    }
                }
                else
                {
                    GUILayout.Label("Time: " + (int)stepValue, GUILayout.Width(60));
                    stepValue = GUILayout.HorizontalSlider(stepValue, 1f, 120f, GUILayout.Height(20));
                    if (GUILayout.Button("Save", GUILayout.Width(45)))
                    {
                        timedNodeMain.GetStep(timedEditStep).numSteps = (int)stepValue;
                        timedEditStep = -1;
                    }
                }

                GUILayout.EndHorizontal();
            }

            GUILayout.BeginHorizontal();

            if (timedPanelAdd)
            {
                GUILayout.Label("Time: " + (int) stepValue, GUILayout.Width(60));
                stepValue = GUILayout.HorizontalSlider(stepValue, 1f, 120f, GUILayout.Height(20));
                if (GUILayout.Button("Add", GUILayout.Width(45)))
                {
                    for (var i = 0; i < SelectedNodeIndexes.Count; i++)
                    {
                        var timedNode = TrafficLightsTimed.GetTimedLight(SelectedNodeIndexes[i]);
                        timedNode.addStep((int) stepValue);
                    }
                    timedPanelAdd = false;
                }
            }
            else
            {
                if (GUILayout.Button("Add Step"))
                {
                    timedPanelAdd = true;
                }
            }

            GUILayout.EndHorizontal();

            if (timedNodeMain.NumSteps() > 1)
            {
                if (nodeSimulation.TimedTrafficLightsActive)
                {
                    if (GUILayout.Button("Stop"))
                    {
                        for (var i = 0; i < SelectedNodeIndexes.Count; i++)
                        {
                            var timedNode = TrafficLightsTimed.GetTimedLight(SelectedNodeIndexes[i]);
                            timedNode.stop();
                        }
                    }
                }
                else
                {
                    if (GUILayout.Button("Start"))
                    {
                        for (var i = 0; i < SelectedNodeIndexes.Count; i++)
                        {
                            var timedNode = TrafficLightsTimed.GetTimedLight(SelectedNodeIndexes[i]);
                            timedNode.start();
                        }
                    }
                }
            }

            GUILayout.Space(30);

            if (GUILayout.Button("REMOVE"))
            {
                DisableTimed();
            }
        }

        protected void _guiPrioritySigns()
        {
            var hoveredSegment = false;

            if (_selectedNetNodeIdx != 0)
            {
                var node = GetNetNode(_selectedNetNodeIdx);

                var segmentId = 0;

                for (var i = 0; i < 8; i++)
                {
                    segmentId = node.GetSegment(i);

                    if (segmentId != 0)
                    {
                        var segment = Singleton<NetManager>.instance.m_segments.m_buffer[(int)segmentId];

                        var position = node.m_position;

                        if (segment.m_startNode == _selectedNetNodeIdx)
                        {
                            position.x += segment.m_startDirection.x * 10f;
                            position.y += segment.m_startDirection.y * 10f;
                            position.z += segment.m_startDirection.z * 10f;
                        }
                        else
                        {
                            position.x += segment.m_endDirection.x * 10f;
                            position.y += segment.m_endDirection.y * 10f;
                            position.z += segment.m_endDirection.z * 10f;
                        }

                        var screenPos = Camera.main.WorldToScreenPoint(position);

                        Vector3 diff = position - Camera.main.transform.position;
                        float zoom = 1.0f / diff.magnitude * 100f;

                        var size = 85f * zoom;

                        screenPos.y = Screen.height - screenPos.y;

                        var guiColor = GUI.color;

                        if (_hoveredButton[0] == segmentId && _hoveredButton[1] == 0)
                        {
                            guiColor.a = 0.8f;
                        }
                        else
                        {
                            guiColor.a = 0.25f;
                        }

                        GUI.color = guiColor;

                        Rect myRect = new Rect(screenPos.x - size/2, screenPos.y - size/2, size, size);

                        var isPrioritySegment = TrafficPriority.isPrioritySegment(_selectedNetNodeIdx, segmentId);

                        if (isPrioritySegment)
                        {
                            var prioritySegment = TrafficPriority.getPrioritySegment(_selectedNetNodeIdx, segmentId);

                            if (prioritySegment.type == PrioritySegment.PriorityType.Main)
                            {
                                GUI.DrawTexture(myRect, signPriority);

                                if (myRect.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 0;
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;
                                        prioritySegment.type = PrioritySegment.PriorityType.Yield;
                                    }
                                }
                            }
                            else if (prioritySegment.type == PrioritySegment.PriorityType.Yield)
                            {
                                GUI.DrawTexture(myRect, signYield);

                                if (myRect.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 0;
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;
                                        prioritySegment.type = PrioritySegment.PriorityType.Stop;
                                    }
                                }
                            }
                            else if (prioritySegment.type == PrioritySegment.PriorityType.Stop)
                            {
                                GUI.DrawTexture(myRect, signStop);

                                if (myRect.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 0;
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;

                                        prioritySegment.type = PrioritySegment.PriorityType.None;
                                    }
                                }
                            }
                            else
                            {
                                GUI.DrawTexture(myRect, signNone);

                                if (myRect.Contains(Event.current.mousePosition))
                                {
                                    _hoveredButton[0] = segmentId;
                                    _hoveredButton[1] = 0;
                                    hoveredSegment = true;

                                    if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                    {
                                        uiClickedSegment = true;

                                        var numMainRoads = 0;

                                        for (var s = 0; s < 8; s++)
                                        {
                                            var segmentId2 = node.GetSegment(s);

                                            if (segmentId2 != 0 && TrafficPriority.isPrioritySegment(_selectedNetNodeIdx, segmentId2))
                                            {
                                                var prioritySegment2 = TrafficPriority.getPrioritySegment(_selectedNetNodeIdx, segmentId2);

                                                if (prioritySegment2.type == PrioritySegment.PriorityType.Main)
                                                {
                                                    numMainRoads++;
                                                }
                                            }
                                        }

                                        prioritySegment.type = numMainRoads >= 2 ? PrioritySegment.PriorityType.Yield : PrioritySegment.PriorityType.Main;
                                    }
                                }
                            }
                        }
                        else
                        {
                            GUI.DrawTexture(myRect, signNone);

                            if (myRect.Contains(Event.current.mousePosition))
                            {
                                _hoveredButton[0] = segmentId;
                                _hoveredButton[1] = 0;
                                hoveredSegment = true;

                                if (Input.GetMouseButtonDown(0) && !uiClickedSegment)
                                {
                                    uiClickedSegment = true;

                                    var numMainRoads = 0;

                                    for (var s = 0; s < 8; s++)
                                    {
                                        var segmentId2 = node.GetSegment(s);

                                        if (segmentId2 != 0 && TrafficPriority.isPrioritySegment(_selectedNetNodeIdx, segmentId2))
                                        {
                                            var prioritySegment2 = TrafficPriority.getPrioritySegment(_selectedNetNodeIdx, segmentId2);

                                            if (prioritySegment2.type == PrioritySegment.PriorityType.Main)
                                            {
                                                numMainRoads++;
                                            }
                                        }
                                    }

                                    TrafficPriority.addPrioritySegment(_selectedNetNodeIdx, segmentId, numMainRoads >= 2 ? PrioritySegment.PriorityType.Yield : PrioritySegment.PriorityType.Main);
                                }
                            }
                        }
                    }
                }
            }

            if (!hoveredSegment)
            {
                _hoveredButton[0] = 0;
                _hoveredButton[1] = 0;
            }
        }

        protected void _switchTrafficLights()
        {
            var node = GetNetNode(_hoveredNetNodeIdx);

            if ((node.m_flags & NetNode.Flags.TrafficLights) != NetNode.Flags.None)
            {
                if (TrafficLightsTimed.IsTimedLight(_hoveredNetNodeIdx))
                {
                    ShowToolInfo(true, "Node is part of timed script", node.m_position);
                }
                else
                {
                    node.m_flags &= ~NetNode.Flags.TrafficLights;
                }
            }
            else
            {
                node.m_flags |= NetNode.Flags.TrafficLights;
            }

            SetNetNode(_hoveredNetNodeIdx, node);
        }

        public void AddTimedNodes()
        {
            for (var i = 0; i < SelectedNodeIndexes.Count; i++)
            {
                var node = GetNetNode(SelectedNodeIndexes[i]);
                CustomRoadAI.AddNodeToSimulation(SelectedNodeIndexes[i]);
                var nodeSimulation = CustomRoadAI.GetNodeSimulation(SelectedNodeIndexes[i]);
                nodeSimulation.FlagTimedTrafficLights = true;

                for (int s = 0; s < node.CountSegments(); s++)
                {
                    var segment = node.GetSegment(s);

                    if (segment != 0 && !TrafficPriority.isPrioritySegment(SelectedNodeIndexes[i], segment))
                    {
                        TrafficPriority.addPrioritySegment(SelectedNodeIndexes[i], segment, PrioritySegment.PriorityType.None);
                    }
                }
            }
        }

        public bool SwitchManual()
        {
            if (_selectedNetNodeIdx != 0)
            {
                var node = GetNetNode(_selectedNetNodeIdx);
                var nodeSimulation = CustomRoadAI.GetNodeSimulation(_selectedNetNodeIdx);

                if (nodeSimulation == null)
                {
                    //node.Info.m_netAI = _myGameObject.GetComponent<CustomRoadAI>();
                    //node.Info.m_netAI.m_info = node.Info;
                    CustomRoadAI.AddNodeToSimulation(_selectedNetNodeIdx);
                    nodeSimulation = CustomRoadAI.GetNodeSimulation(_selectedNetNodeIdx);
                    nodeSimulation.FlagManualTrafficLights = true;

                    for (int s = 0; s < node.CountSegments(); s++)
                    {
                        var segment = node.GetSegment(s);

                        if (segment != 0 && !TrafficPriority.isPrioritySegment(_selectedNetNodeIdx, segment))
                        {
                            TrafficPriority.addPrioritySegment(_selectedNetNodeIdx, segment, PrioritySegment.PriorityType.None);
                        }
                    }

                    return true;
                }
                else
                {
                    nodeSimulation.FlagManualTrafficLights = false;
                    CustomRoadAI.RemoveNodeFromSimulation(_selectedNetNodeIdx);

                    for (int s = 0; s < node.CountSegments(); s++)
                    {
                        var segment = node.GetSegment(s);

                        if (segment != 0 && !TrafficPriority.isPrioritySegment(_selectedNetNodeIdx, segment))
                        {
                            TrafficPriority.addPrioritySegment(_selectedNetNodeIdx, segment, PrioritySegment.PriorityType.None);
                        }
                    }
                }
            }

            return false;
        }

        public void DisableManual()
        {
            if (_selectedNetNodeIdx != 0)
            {
                var nodeSimulation = CustomRoadAI.GetNodeSimulation(_selectedNetNodeIdx);

                if (nodeSimulation != null && nodeSimulation.FlagManualTrafficLights)
                {
                    nodeSimulation.FlagManualTrafficLights = false;
                    CustomRoadAI.RemoveNodeFromSimulation(_selectedNetNodeIdx);
                }
            }
        }

        public void DisableTimed()
        {
            if (SelectedNodeIndexes.Count > 0)
            {
                for (var i = 0; i < SelectedNodeIndexes.Count; i++)
                {
                    var node = GetNetNode(SelectedNodeIndexes[i]);
                    var nodeSimulation = CustomRoadAI.GetNodeSimulation(SelectedNodeIndexes[i]);

                    TrafficLightsTimed.RemoveTimedLight(SelectedNodeIndexes[i]);

                    if (nodeSimulation != null)
                    {
                        nodeSimulation.FlagTimedTrafficLights = false;
                        CustomRoadAI.RemoveNodeFromSimulation(SelectedNodeIndexes[i]);
                    }
                }
            }
        }

        public NetNode GetCurrentNetNode()
        {
            return GetNetNode(_hoveredNetNodeIdx);
        }
        public static NetNode GetNetNode(ushort index)
        {
            return Singleton<NetManager>.instance.m_nodes.m_buffer[index];
        }

        public static void SetNetNode(ushort index, NetNode node)
        {
            Singleton<NetManager>.instance.m_nodes.m_buffer[index] = node;
        }

        public static void addListNode(ushort node)
        {
            SelectedNodeIndexes.Add(node);
        }

        public static bool containsListNode(ushort node)
        {
            return SelectedNodeIndexes.Contains(node);
        }

        public static void removeListNode(ushort node)
        {
            SelectedNodeIndexes.Remove(node);
        }
    }
}
